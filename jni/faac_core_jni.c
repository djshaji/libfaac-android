/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#include <jni.h>
#include <stdlib.h>
#include <string.h>
#include "faac.h"


#define JNICLSItem(cls,jfuncName,typestring) { #jfuncName,typestring,(void*)cls##_##jfuncName }

// 实现jni接口
#define CORE_JAVA_CLASS "jni/i51talk/aac/Core"

// native function
#define CORE_ALL_NATIVES \
	JNIItem(New,"(IIII)J"), \
	JNIItem(Del,"(J)V"), \
	JNIItem(GetInputSamples,"(J)I"), \
	JNIItem(GetOutputBufferSize,"(J)I"), \
	JNIItem(Proc,"(J[S[B)I"), \
	JNIItem(ProcBytes,"(J[B[B)I"), \


#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

#ifdef __aarch64__
#define DPTR 
#else
#define DPTR (int)
#endif

#ifdef __cplusplus
extern "C" {
#endif

struct Aac_t {
	faacEncHandle enc;
	unsigned long inputSamples;
	unsigned long maxOutputBytes;
//	char* inputBuffer;
	unsigned char* outputBuffer;
};
typedef struct Aac_t* PAac;

// 编码对象
// 初始化对象
jlong Aac_New(JNIEnv *jenv, jclass jcls, jint sampleRate, jint numChannels, jint bitRate, jint outputFormat) {
	unsigned long inputSamples = 0;
	unsigned long maxOutputBytes = 0;
	faacEncHandle enc = 0;
	PAac aac = NULL;
	enc = faacEncOpen((unsigned long) sampleRate, numChannels, &inputSamples, &maxOutputBytes);
	if (!enc) return 0;
	
	aac = (PAac)malloc(sizeof(struct Aac_t));
	aac->enc = enc;
	aac->inputSamples = inputSamples;
	aac->maxOutputBytes = maxOutputBytes;
	aac->outputBuffer = (unsigned char*)malloc(maxOutputBytes);
	
	return (jlong) DPTR aac;
}
// 删除对象
void Aac_Del(JNIEnv *jenv, jclass jcls, jlong enc) {
	PAac aac = (PAac) DPTR enc;
	if (aac->enc) { // 释放编码器
		faacEncClose(aac->enc);
		aac->enc = NULL;
	}
	// 释放输出buffer
	if (aac->outputBuffer) {
		free(aac->outputBuffer);
		aac->outputBuffer = NULL;
	}
	free(aac);
}
// 获取输入采样数
jint Aac_GetInputSamples(JNIEnv *jenv, jclass jcls, jlong enc) {
	PAac aac = (PAac) DPTR enc;
	return (jint)aac->inputSamples;
}
// 获取输出buffer大小
jint Aac_GetOutputBufferSize(JNIEnv *jenv, jclass jcls, jlong enc) {
	PAac aac = (PAac) DPTR enc;
	return (jint)aac->maxOutputBytes;
}
// 编码数据 返回大小
jint Aac_Proc(JNIEnv *jenv, jclass jcls, jlong enc, jshortArray jdata, jbyteArray jout) {
	PAac aac = (PAac) DPTR enc;
	int result = 0 ;
	jshort* data = NULL;
	if (!enc||!jdata||!jout) return 0;

	data = (*jenv)->GetShortArrayElements(jenv, jdata, 0);
	if (!data) return 0;

	result = faacEncEncode(aac->enc, (int32_t*)data, aac->inputSamples, aac->outputBuffer, aac->maxOutputBytes);

	if (data) {
		(*jenv)->ReleaseShortArrayElements(jenv, jdata, data, 0);
	}
	
	if (result>0) {
		(*jenv)->SetByteArrayRegion(jenv,jout,0,result,(jbyte*)aac->outputBuffer);	
	}
	return result;
}
jint Aac_ProcBytes(JNIEnv *jenv, jclass jcls, jlong enc, jbyteArray jdata, jbyteArray jout) {
	PAac aac = (PAac) DPTR enc;
	int result = 0 ;
	jbyte* data = NULL;
	if (!enc||!jdata||!jout) return 0;

	data = (*jenv)->GetByteArrayElements(jenv, jdata, 0);
	if (!data) return 0;

	result = faacEncEncode(aac->enc, (int32_t*)data, aac->inputSamples, aac->outputBuffer, aac->maxOutputBytes);

	if (data) {
		(*jenv)->ReleaseByteArrayElements(jenv, jdata, data, 0);
	}
	
	if (result>0) {
		(*jenv)->SetByteArrayRegion(jenv,jout,0,result,(jbyte*)aac->outputBuffer);	
	}
	return result;
}

#include <android/log.h>
#define SL_Android_Log(...) __android_log_print(ANDROID_LOG_VERBOSE, "aac_core_jni", __VA_ARGS__)
// 注册native函数
int JNI_RegisterNatives(JNIEnv* env,const char* java_class,const JNINativeMethod* native_funcs,int native_count)
{
	// get jni env
	jclass clazz = NULL;
	int nResult;
    /* look up the class */
    clazz = (*env)->FindClass(env,java_class);
    if (clazz==NULL)
	{
		SL_Android_Log("Can't find class %s\n",java_class);
        return -2;
    }
    /* register all the methods */
	nResult = (*env)->RegisterNatives(env,clazz,native_funcs,native_count);
	SL_Android_Log("Calling RegisterNatives():env=0x%08x class=0x%08x funcs=0x%08x count=0x%08x ret=%d!",
		 DPTR env, DPTR clazz, DPTR native_funcs,native_count,nResult);
    if (nResult!=JNI_OK)
    {
        return -3;
    }
    return native_count;
}

// JNI实现，必须写上JNI_OnLoad方法以获取JVM
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* ajvm, void* reserved)
{
	JNIEnv* env = NULL;
	jint nResult = (*ajvm)->GetEnv(ajvm,(void**)&env,JNI_VERSION_1_4);
	if (nResult!=JNI_OK)
	{
		return -1;
	}
	{
#define JNIItem(func,ty) JNICLSItem(Aac,func,ty)
		// Asr_xxx
		const JNINativeMethod native_funcs[] = {
			CORE_ALL_NATIVES
		};
#undef JNIItem
		JNI_RegisterNatives(env,CORE_JAVA_CLASS,native_funcs,sizeof(native_funcs)/sizeof(native_funcs[0]));
	}
	return JNI_VERSION_1_4;
}

#ifdef __cplusplus
};
#endif
